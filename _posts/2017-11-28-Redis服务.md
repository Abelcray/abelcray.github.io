# Redis键值数据库

<!--markdown-->> Redis是一个开源的使用ANSIC语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API，属于NoSQL的一种。Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sortedset --有序集合)和hash（哈希类型）。Redis是一种高级key-value数据库。它跟memcached类似，不过数据可以持久化，而且支持的数据类型很丰富。有字符串，链表，集合和有序集合。支持在服务器端计算集合的并，交和补集(difference)等，还支持多种排序功能。所以Redis也可以被看成是一个数据结构服务器。

**原理：**
Redis的所有数据都是保存在内存中的，不定期的通过异步方式保存到磁盘上（*.rdb的文件内）（此为RDB半持久化模式）；也可以把每一次的数据变化都写入到（*.aof的文件内），成为AOF全持久化模式。

**特点：**
Redis属于内存数据库，采用内存缓存机制，响应快，但是数据的持久性不高。
可以作为关系型数据库的补充，减轻Mysql数据库压力，提高用户对站点的交互性能，同时支持主从同步，并且安装配置简单易操作。

安装Redis

```
wget  http://download.redis.io/releases/redis-2.8.13.tar.gz 
tar zxf redis-2.8.13.tar.gz
cd redis-2.8.13
make PREFIX=/usr/local/redis install
cp  redis.conf   /usr/local/redis
```

配置环境变量

```
echo 'export PATH=$PATH:/usr/local/redis/bin/' >>/etc/profile
source /etc/profile
```

使用nohub启动命令

```
nohub /usr/local/redis/bin/redis-server /usr/local/redis/redis.conf &
```

停止命令

```
/usr/local/redis/bin/redis-cli -p 6379 shutdown
```

redis常用配置参数详解

```
#daemonize no 
daemonize yes
```

Linux Shell终端运行redis，改为yes即后台运行Redis服务；

```
pidfile /var/run/redis_6379.pid
```

 当运行多个 redis 服务时，需要指定不同的pid文件和端口

```
port 6379
```

 指定redis运行的端口，默认是 6379

```
tcp-backlog 511
```

 在高并发的环境中，为避免慢客户端的连接问题，需要设置一个高速后台日志

```
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1
```

 指定redis只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求

```
timeout 0
```

设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接；

```
tcp-keepalive 0
```

 在Linux 上，指定值（秒）用于发送 ACKs 的时间。注意关闭连接需要双倍的时间。默认为 0 。

```
loglevel notice
```

 Redis总共支持四个日志级别： debug 、 verbose 、 notice 、 warning ，默认为 verbose
 debug     记录很多信息，用于开发和测试
 varbose   有用的信息，不像 debug 会记录那么多
 notice    普通的 verbose ，常用于生产环境
 warning   只有非常重要或者严重的信息会记录到日志

```
 logfile /var/log/redis/redis.log
```

配置 log 文件地址
默认值为 stdout ，标准输出，若后台模式会输出到 /dev/null 。

```
databases 16
```

可用数据库数
默认值为16 ，默认数据库为0，数据库范围在 0- （ database-1 ）之间

```
#save <seconds> <changes>
```

save 900 1  900 秒内至少有 1 个 key 被改变
save 300 10  300 秒内至少有 10 个 key 被改变
save 60 10000  60 秒内至少有 10000 个 key 被改变
比如默认配置文件中的设置，就设置了三个条件
 save 900 1
 save 300 10
 save 60 10000
数据写入磁盘快照设置，保存数据到磁盘
指出在多长时间内，有多少次更新操作，就将数据同步到数据文件 rdb 。
相当于条件触发抓取快照，这个可以多个条件配合

```
stop-writes-on-bgsave-error yes
```

  后台存储错误停止写。

```
rdbcompression yes

```

  存储至本地数据库时（持久化到 rdb 文件）是否压缩数据，默认为 yes

```
dbfilename dump.rdb

```

  本地持久化数据库文件名，默认值为 dump.rdb

```
dir /var/lib/redis/

```

  工作目录
  数据库镜像备份的文件放置的路径。
  这里的路径跟文件名要分开配置是因为 redis 在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成，
  再把该该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中。
 AOF 文件也会存放在这个目录下面
  注意这里必须制定一个目录而不是文件

------

################################# 复制 #################################

```
# slaveof <masterip><masterport>

```

  主从复制 . 设置该数据库为其他数据库的从数据库 .
  设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步
 masterauth <master-password>
  当 master 服务设置了密码保护时 ( 用 requirepass 制定的密码 )
 slave 服务连接 master 的密码

```
slave-serve-stale-data yes

```

  当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：
 1)  如果 slave-serve-stale-data 设置为 yes( 默认设置 ) ，从库会继续响应客户端的请求
 2)  如果 slave-serve-stale-data 是指为 no ，出去 INFO 和 SLAVOF 命令之外的任何请求都会返回一个
     错误 "SYNC with master in progress"

```
slaveread-only yes

```

  配置 slave 实例是否接受写。写 slave 对存储短暂数据（在同 master 数据同步后可以很容易地被删除）是有用的，但未配置的情况下，客户端写可能会发送问题。
  从 Redis2.6 后，默认 slave 为 read-only

```
# repl-ping-slave-period 10

```

  从库会按照一个时间间隔向主库发送 PINGs. 可以通过 repl-ping-slave-period 设置这个时间间隔，默认是 10 秒

```
 repl-timeout 60

```

 repl-timeout  设置主库批量数据传输时间或者 ping 回复时间间隔，默认值是 60 秒
  一定要确保 repl-timeout 大于 repl-ping-slave-period

```
repl-disable-tcp-nodelay no

```

  在 slave socket 的 SYNC 后禁用 TCP_NODELAY
  如果选择“ yes ” ,Redis 将使用一个较小的数字 TCP 数据包和更少的带宽将数据发送到 slave ， 但是这可能导致数据发送到 slave 端会有延迟 , 如果是 Linux kernel 的默认配置，会达到 40 毫秒 .
  如果选择 "no" ，则发送数据到 slave 端的延迟会降低，但将使用更多的带宽用于复制 .

```
# repl-backlog-size 1mb

```

  设置复制的后台日志大小。
  复制的后台日志越大， slave 断开连接及后来可能执行部分复制花的时间就越长。
  后台日志在至少有一个 slave 连接时，仅仅分配一次。

```
# repl-backlog-ttl 3600

```

  在 master 不再连接 slave 后，后台日志将被释放。下面的配置定义从最后一个 slave 断开连接后需要释放的时间（秒）。
 0 意味着从不释放后台日志



```
slave-priority 100

```

  如果 master 不能再正常工作，那么会在多个 slave 中，选择优先值最小的一个 slave 提升为 master ，优先值为 0 表示不能提升为 master 。

```
 min-slaves-to-write 3
 min-slaves-max-lag 10

```

  如果少于 N 个 slave 连接，且延迟时间 <=M 秒，则 master 可配置停止接受写操作。
  例如需要至少 3 个 slave 连接，且延迟 <=10 秒的配置：
  设置 0 为禁用
   默认 min-slaves-to-write 为 0 （禁用）， min-slaves-max-lag 为 10

------

################################## 安全 ###################################

```
 requirepass test

```

  设置客户端连接后进行任何其他指定前需要使用的密码。
  警告：因为 redis 速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行 150K 次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解

```
rename-conmmand 

```

  命令重命名 .
  在一个共享环境下可以重命名相对危险的命令。比如把 CONFIG 重名为一个不容易猜测的字符。
  举例 :
 rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
  如果想删除一个命令，直接把它重命名为一个空字符 "" 即可，如下：
 rename-command CONFIG ""

------

###################################约束###################################

```
 maxclients 10000

```

设置同一时间最大客户端连接数，默认无限制， 
Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，
如果设置  maxclients 0 ，表示不作限制。
当客户端连接数到达限制时， Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息

```
 maxmemory <bytes>

```

  指定 Redis 最大内存限制， Redis 在启动时会把数据加载到内存中，达到最大内存后， Redis 会按照清除策略尝试清除已到期的 Key
  如果 Redis 依照策略清除后无法提供足够空间，或者策略设置为 ”noeviction” ，则使用更多空间的命令将会报错，例如 SET, LPUSH 等。但仍然可以进行读取操作
  注意： Redis 新的 vm 机制，会把 Key 存放内存， Value 会存放在 swap 区

```
 maxmemory-policy volatile-lru  

```

  该选项对 LRU 策略很有用。
 maxmemory 的设置比较适合于把 redis 当作于类似 memcached 的缓存来使用，而不适合当做一个真实的 DB 。
  当把 Redis 当做一个真实的数据库使用的时候，内存使用将是一个很大的开销
  当内存达到最大值的时候 Redis 会选择删除哪些数据？有五种方式可供选择
 volatile-lru ->  利用 LRU 算法移除设置过过期时间的 key (LRU: 最近使用  Least RecentlyUsed )
 allkeys-lru ->  利用 LRU 算法移除任何 key
 volatile-random ->  移除设置过过期时间的随机 key
 allkeys->random -> remove a randomkey, any key
 volatile-ttl ->  移除即将过期的 key(minor TTL)
 noeviction ->  不移除任何可以，只是返回一个写错误
  注意：对于上面的策略，如果没有合适的 key 可以移除，当写的时候 Redis 会返回一个错误
  默认是 :  volatile-lru

```
 maxmemory-samples 3

```

 LRU  和  minimal TTL 算法都不是精准的算法，但是相对精确的算法 ( 为了节省内存 ) ，随意你可以选择样本大小进行检测。
 Redis 默认的灰选择 3 个样本进行检测，你可以通过 maxmemory-samples 进行设置

------

############################## AOF###############################

```
appendonly  no

```

  默认情况下， redis 会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。
  所以 redis 提供了另外一种更加高效的数据库备份及灾难恢复方式。
  开启 append only 模式之后， redis 会把所接收到的每一次写操作请求都追加到 appendonly.aof 文件中，当 redis 重新启动时，会从该文件恢复出之前的状态。
  但是这样会造成 appendonly.aof 文件过大，所以 redis 还支持了 BGREWRITEAOF 指令，对 appendonly.aof 进行重新整理。
  你可以同时开启 asynchronous dumps 和  AOF

```
 appendfilename  appendonly.aof

```

 AOF 文件名称  ( 默认 : "appendonly.aof")

```
appendfsync everysec

```

 Redis 支持三种同步 AOF 文件的策略 :
 no:  不进行同步，系统去操作  . Faster.
 always: always 表示每次有写操作都进行同步 . Slow, Safest.
 everysec:  表示对写操作进行累积，每秒同步一次 . Compromise.
 默认是 "everysec" ，按照速度和安全折中这是最好的。
 如果想让 Redis 能更高效的运行，你也可以设置为 "no" ，让操作系统决定什么时候去执行
 或者相反想让数据更安全你也可以设置为 "always"
 如果不确定就用  "everysec".



```
no-appendfsync-on-rewrite no

```

 AOF 策略设置为 always 或者 everysec 时，后台处理进程 ( 后台保存或者 AOF 日志重写 ) 会执行大量的 I/O 操作
  在某些 Linux 配置中会阻止过长的 fsync() 请求。注意现在没有任何修复，即使 fsync 在另外一个线程进行处理
  为了减缓这个问题，可以设置这个参数 no-appendfsync-on-rewrite

```
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

```

 AOF  自动重写
  当 AOF 文件增长到一定大小的时候 Redis 能够调用  BGREWRITEAOF  对日志文件进行重写
  它是这样工作的： Redis 会记住上次进行些日志后文件的大小 ( 如果从开机以来还没进行过重写，那日志大小在开机的时候确定 )
  基础大小会同现在的大小进行比较。如果现在的大小比基础大小大制定的百分比，重写功能将启动
  同时需要指定一个最小大小用于 AOF 重写，这个用于阻止即使文件很小但是增长幅度很大也去重写 AOF 文件的情况
  设置  percentage 为 0 就关闭这个特性

------

######## # LUA SCRIPTING #########

```
lua-time-limit 5000

```

 一个 Lua 脚本最长的执行时间为 5000 毫秒（ 5 秒），如果为 0 或负数表示无限执行时间。

------

################################LOW LOG################################

```
slowlog-log-slower-than 10000

```

 Redis Slow Log  记录超过特定执行时间的命令。执行时间不包括 I/O 计算比如连接客户端，返回结果等，只是命令执行时间
 可以通过两个参数设置 slow log ：一个是告诉 Redis 执行超过多少时间被记录的参数 slowlog-log-slower-than( 微秒) ，另一个是 slow log 的长度。当一个新命令被记录的时候最早的命令将被从队列中移除
 下面的时间以微妙为单位，因此 1000000 代表一秒。
 注意指定一个负数将关闭慢日志，而设置为 0 将强制每个命令都会记录
 对日志长度没有限制，只是要注意它会消耗内存

```
slowlog-max-len 128

```

 可以通过  SLOWLOG RESET 回收被慢日志消耗的内存
 推荐使用默认值 128 ，当慢日志超过 128 时，最先进入队列的记录会被踢出

**（注：使用Redis必须要有对应的插件支持。）**



